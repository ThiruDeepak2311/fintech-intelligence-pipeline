{"ast":null,"code":"const {\n  Client\n} = require('pg');\nclass DatabaseService {\n  constructor() {\n    // Railway PostgreSQL connection string - hardcoded for deployment\n    this.connectionString = 'postgresql://postgres:vDfzLbuvZxfVjUUgNInZPsHSidoCtHkD@interchange.proxy.rlwy.net:57621/railway';\n    this.client = null;\n  }\n  async connect() {\n    if (!this.connectionString) {\n      throw new Error('Database URL not provided. Set REACT_APP_DATABASE_URL environment variable.');\n    }\n    try {\n      this.client = new Client({\n        connectionString: this.connectionString,\n        ssl: {\n          rejectUnauthorized: false // Required for Railway PostgreSQL\n        }\n      });\n      await this.client.connect();\n      console.log('Connected to PostgreSQL database');\n      return true;\n    } catch (error) {\n      console.error('Database connection failed:', error);\n      throw error;\n    }\n  }\n  async disconnect() {\n    if (this.client) {\n      await this.client.end();\n      this.client = null;\n    }\n  }\n  async getLatestStockData() {\n    /**\r\n     * Get the most recent stock data with AI analysis\r\n     * Returns: Combined stock metrics and AI recommendations\r\n     */\n    try {\n      if (!this.client) await this.connect();\n      const query = `\n        SELECT \n          dm.id,\n          dm.date,\n          dm.symbol,\n          dm.open_price,\n          dm.close_price,\n          dm.high_price,\n          dm.low_price,\n          dm.volume,\n          dm.vwap,\n          dm.transactions,\n          ar.sentiment,\n          ar.risk_score,\n          ar.price_prediction,\n          ar.recommendations,\n          ar.full_analysis,\n          ar.model_used,\n          (dm.close_price - dm.open_price) as price_change,\n          ((dm.close_price - dm.open_price) / dm.open_price * 100) as change_percent\n        FROM daily_metrics dm\n        LEFT JOIN ai_recommendations ar ON dm.id = ar.metrics_id\n        ORDER BY dm.date DESC, dm.id DESC\n        LIMIT 1\n      `;\n      const result = await this.client.query(query);\n      if (result.rows.length === 0) {\n        return null;\n      }\n      const row = result.rows[0];\n      return {\n        id: row.id,\n        date: row.date,\n        symbol: row.symbol,\n        stockData: {\n          open: parseFloat(row.open_price),\n          close: parseFloat(row.close_price),\n          high: parseFloat(row.high_price),\n          low: parseFloat(row.low_price),\n          volume: parseInt(row.volume),\n          vwap: parseFloat(row.vwap),\n          transactions: parseInt(row.transactions),\n          change: parseFloat(row.price_change),\n          changePercent: parseFloat(row.change_percent)\n        },\n        aiAnalysis: {\n          sentiment: row.sentiment,\n          riskScore: row.risk_score,\n          pricePrediction: parseFloat(row.price_prediction),\n          recommendations: row.recommendations,\n          analysis: row.full_analysis,\n          model: row.model_used\n        }\n      };\n    } catch (error) {\n      console.error('Error fetching latest stock data:', error);\n      throw error;\n    }\n  }\n  async getHistoricalData(days = 30) {\n    /**\r\n     * Get historical stock data for charts\r\n     * Returns: Array of daily stock data for specified number of days\r\n     */\n    try {\n      if (!this.client) await this.connect();\n      const query = `\n        SELECT \n          date,\n          symbol,\n          open_price,\n          close_price,\n          high_price,\n          low_price,\n          volume,\n          vwap\n        FROM daily_metrics\n        ORDER BY date DESC\n        LIMIT $1\n      `;\n      const result = await this.client.query(query, [days]);\n\n      // Reverse to get chronological order for charts\n      return result.rows.reverse().map(row => ({\n        date: row.date,\n        symbol: row.symbol,\n        open: parseFloat(row.open_price),\n        close: parseFloat(row.close_price),\n        high: parseFloat(row.high_price),\n        low: parseFloat(row.low_price),\n        volume: parseInt(row.volume),\n        vwap: parseFloat(row.vwap)\n      }));\n    } catch (error) {\n      console.error('Error fetching historical data:', error);\n      throw error;\n    }\n  }\n  async getAllRecommendations() {\n    /**\r\n     * Get all AI recommendations with corresponding stock data\r\n     * Returns: Array of recommendations with stock context\r\n     */\n    try {\n      if (!this.client) await this.connect();\n      const query = `\n        SELECT \n          dm.date,\n          dm.symbol,\n          dm.open_price,\n          dm.close_price,\n          ar.sentiment,\n          ar.risk_score,\n          ar.price_prediction,\n          ar.recommendations,\n          ar.full_analysis,\n          ar.model_used,\n          ((dm.close_price - dm.open_price) / dm.open_price * 100) as change_percent\n        FROM daily_metrics dm\n        INNER JOIN ai_recommendations ar ON dm.id = ar.metrics_id\n        ORDER BY dm.date DESC\n      `;\n      const result = await this.client.query(query);\n      return result.rows.map(row => ({\n        date: row.date,\n        symbol: row.symbol,\n        actualPrice: parseFloat(row.close_price),\n        openPrice: parseFloat(row.open_price),\n        sentiment: row.sentiment,\n        riskScore: row.risk_score,\n        pricePrediction: parseFloat(row.price_prediction),\n        recommendations: row.recommendations,\n        analysis: row.full_analysis,\n        model: row.model_used,\n        changePercent: parseFloat(row.change_percent),\n        predictionAccuracy: this.calculatePredictionAccuracy(parseFloat(row.price_prediction), parseFloat(row.close_price))\n      }));\n    } catch (error) {\n      console.error('Error fetching recommendations:', error);\n      throw error;\n    }\n  }\n  async getPerformanceMetrics() {\n    /**\r\n     * Get system performance and analysis metrics\r\n     * Returns: Statistical summary of system performance\r\n     */\n    try {\n      if (!this.client) await this.connect();\n\n      // Count total records\n      const totalDaysQuery = 'SELECT COUNT(*) as count FROM daily_metrics';\n      const totalRecommendationsQuery = 'SELECT COUNT(*) as count FROM ai_recommendations';\n\n      // Sentiment distribution\n      const sentimentQuery = `\n        SELECT sentiment, COUNT(*) as count \n        FROM ai_recommendations \n        GROUP BY sentiment\n      `;\n\n      // Average risk score\n      const avgRiskQuery = 'SELECT AVG(risk_score) as avg_risk FROM ai_recommendations';\n\n      // Price range analysis\n      const priceRangeQuery = `\n        SELECT \n          MIN(close_price) as min_price,\n          MAX(close_price) as max_price,\n          AVG(close_price) as avg_price,\n          AVG(volume) as avg_volume\n        FROM daily_metrics\n      `;\n      const [totalDays, totalRecs, sentiments, avgRisk, priceRange] = await Promise.all([this.client.query(totalDaysQuery), this.client.query(totalRecommendationsQuery), this.client.query(sentimentQuery), this.client.query(avgRiskQuery), this.client.query(priceRangeQuery)]);\n\n      // Format sentiment distribution\n      const sentimentDistribution = {};\n      sentiments.rows.forEach(row => {\n        sentimentDistribution[row.sentiment] = parseInt(row.count);\n      });\n      return {\n        totalDaysAnalyzed: parseInt(totalDays.rows[0].count),\n        totalRecommendations: parseInt(totalRecs.rows[0].count),\n        sentimentDistribution,\n        averageRiskScore: parseFloat(avgRisk.rows[0].avg_risk || 0).toFixed(2),\n        priceMetrics: {\n          minPrice: parseFloat(priceRange.rows[0].min_price || 0),\n          maxPrice: parseFloat(priceRange.rows[0].max_price || 0),\n          avgPrice: parseFloat(priceRange.rows[0].avg_price || 0),\n          avgVolume: parseInt(priceRange.rows[0].avg_volume || 0)\n        },\n        lastUpdated: new Date().toISOString()\n      };\n    } catch (error) {\n      console.error('Error fetching performance metrics:', error);\n      throw error;\n    }\n  }\n  calculatePredictionAccuracy(predicted, actual) {\n    /**\r\n     * Calculate how accurate the AI price prediction was\r\n     * Returns: Accuracy percentage\r\n     */\n    if (!predicted || !actual) return 0;\n    const difference = Math.abs(predicted - actual);\n    const accuracy = Math.max(0, 100 - difference / actual * 100);\n    return parseFloat(accuracy.toFixed(2));\n  }\n}\n\n// Export singleton instance\nconst databaseService = new DatabaseService();\nexport default databaseService;","map":{"version":3,"names":["Client","require","DatabaseService","constructor","connectionString","client","connect","Error","ssl","rejectUnauthorized","console","log","error","disconnect","end","getLatestStockData","query","result","rows","length","row","id","date","symbol","stockData","open","parseFloat","open_price","close","close_price","high","high_price","low","low_price","volume","parseInt","vwap","transactions","change","price_change","changePercent","change_percent","aiAnalysis","sentiment","riskScore","risk_score","pricePrediction","price_prediction","recommendations","analysis","full_analysis","model","model_used","getHistoricalData","days","reverse","map","getAllRecommendations","actualPrice","openPrice","predictionAccuracy","calculatePredictionAccuracy","getPerformanceMetrics","totalDaysQuery","totalRecommendationsQuery","sentimentQuery","avgRiskQuery","priceRangeQuery","totalDays","totalRecs","sentiments","avgRisk","priceRange","Promise","all","sentimentDistribution","forEach","count","totalDaysAnalyzed","totalRecommendations","averageRiskScore","avg_risk","toFixed","priceMetrics","minPrice","min_price","maxPrice","max_price","avgPrice","avg_price","avgVolume","avg_volume","lastUpdated","Date","toISOString","predicted","actual","difference","Math","abs","accuracy","max","databaseService"],"sources":["C:/Users/Deepak Thirukkumaran/OneDrive/Desktop/stealth/finpipe/dashboard/src/services/database.js"],"sourcesContent":["const { Client } = require('pg');\r\n\r\nclass DatabaseService {\r\n  constructor() {\r\n    // Railway PostgreSQL connection string - hardcoded for deployment\r\n    this.connectionString = 'postgresql://postgres:vDfzLbuvZxfVjUUgNInZPsHSidoCtHkD@interchange.proxy.rlwy.net:57621/railway';\r\n    this.client = null;\r\n  }\r\n\r\n  async connect() {\r\n    if (!this.connectionString) {\r\n      throw new Error('Database URL not provided. Set REACT_APP_DATABASE_URL environment variable.');\r\n    }\r\n\r\n    try {\r\n      this.client = new Client({\r\n        connectionString: this.connectionString,\r\n        ssl: {\r\n          rejectUnauthorized: false // Required for Railway PostgreSQL\r\n        }\r\n      });\r\n\r\n      await this.client.connect();\r\n      console.log('Connected to PostgreSQL database');\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Database connection failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async disconnect() {\r\n    if (this.client) {\r\n      await this.client.end();\r\n      this.client = null;\r\n    }\r\n  }\r\n\r\n  async getLatestStockData() {\r\n    /**\r\n     * Get the most recent stock data with AI analysis\r\n     * Returns: Combined stock metrics and AI recommendations\r\n     */\r\n    try {\r\n      if (!this.client) await this.connect();\r\n\r\n      const query = `\r\n        SELECT \r\n          dm.id,\r\n          dm.date,\r\n          dm.symbol,\r\n          dm.open_price,\r\n          dm.close_price,\r\n          dm.high_price,\r\n          dm.low_price,\r\n          dm.volume,\r\n          dm.vwap,\r\n          dm.transactions,\r\n          ar.sentiment,\r\n          ar.risk_score,\r\n          ar.price_prediction,\r\n          ar.recommendations,\r\n          ar.full_analysis,\r\n          ar.model_used,\r\n          (dm.close_price - dm.open_price) as price_change,\r\n          ((dm.close_price - dm.open_price) / dm.open_price * 100) as change_percent\r\n        FROM daily_metrics dm\r\n        LEFT JOIN ai_recommendations ar ON dm.id = ar.metrics_id\r\n        ORDER BY dm.date DESC, dm.id DESC\r\n        LIMIT 1\r\n      `;\r\n\r\n      const result = await this.client.query(query);\r\n      \r\n      if (result.rows.length === 0) {\r\n        return null;\r\n      }\r\n\r\n      const row = result.rows[0];\r\n      return {\r\n        id: row.id,\r\n        date: row.date,\r\n        symbol: row.symbol,\r\n        stockData: {\r\n          open: parseFloat(row.open_price),\r\n          close: parseFloat(row.close_price),\r\n          high: parseFloat(row.high_price),\r\n          low: parseFloat(row.low_price),\r\n          volume: parseInt(row.volume),\r\n          vwap: parseFloat(row.vwap),\r\n          transactions: parseInt(row.transactions),\r\n          change: parseFloat(row.price_change),\r\n          changePercent: parseFloat(row.change_percent)\r\n        },\r\n        aiAnalysis: {\r\n          sentiment: row.sentiment,\r\n          riskScore: row.risk_score,\r\n          pricePrediction: parseFloat(row.price_prediction),\r\n          recommendations: row.recommendations,\r\n          analysis: row.full_analysis,\r\n          model: row.model_used\r\n        }\r\n      };\r\n    } catch (error) {\r\n      console.error('Error fetching latest stock data:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getHistoricalData(days = 30) {\r\n    /**\r\n     * Get historical stock data for charts\r\n     * Returns: Array of daily stock data for specified number of days\r\n     */\r\n    try {\r\n      if (!this.client) await this.connect();\r\n\r\n      const query = `\r\n        SELECT \r\n          date,\r\n          symbol,\r\n          open_price,\r\n          close_price,\r\n          high_price,\r\n          low_price,\r\n          volume,\r\n          vwap\r\n        FROM daily_metrics\r\n        ORDER BY date DESC\r\n        LIMIT $1\r\n      `;\r\n\r\n      const result = await this.client.query(query, [days]);\r\n      \r\n      // Reverse to get chronological order for charts\r\n      return result.rows.reverse().map(row => ({\r\n        date: row.date,\r\n        symbol: row.symbol,\r\n        open: parseFloat(row.open_price),\r\n        close: parseFloat(row.close_price),\r\n        high: parseFloat(row.high_price),\r\n        low: parseFloat(row.low_price),\r\n        volume: parseInt(row.volume),\r\n        vwap: parseFloat(row.vwap)\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error fetching historical data:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getAllRecommendations() {\r\n    /**\r\n     * Get all AI recommendations with corresponding stock data\r\n     * Returns: Array of recommendations with stock context\r\n     */\r\n    try {\r\n      if (!this.client) await this.connect();\r\n\r\n      const query = `\r\n        SELECT \r\n          dm.date,\r\n          dm.symbol,\r\n          dm.open_price,\r\n          dm.close_price,\r\n          ar.sentiment,\r\n          ar.risk_score,\r\n          ar.price_prediction,\r\n          ar.recommendations,\r\n          ar.full_analysis,\r\n          ar.model_used,\r\n          ((dm.close_price - dm.open_price) / dm.open_price * 100) as change_percent\r\n        FROM daily_metrics dm\r\n        INNER JOIN ai_recommendations ar ON dm.id = ar.metrics_id\r\n        ORDER BY dm.date DESC\r\n      `;\r\n\r\n      const result = await this.client.query(query);\r\n      \r\n      return result.rows.map(row => ({\r\n        date: row.date,\r\n        symbol: row.symbol,\r\n        actualPrice: parseFloat(row.close_price),\r\n        openPrice: parseFloat(row.open_price),\r\n        sentiment: row.sentiment,\r\n        riskScore: row.risk_score,\r\n        pricePrediction: parseFloat(row.price_prediction),\r\n        recommendations: row.recommendations,\r\n        analysis: row.full_analysis,\r\n        model: row.model_used,\r\n        changePercent: parseFloat(row.change_percent),\r\n        predictionAccuracy: this.calculatePredictionAccuracy(\r\n          parseFloat(row.price_prediction), \r\n          parseFloat(row.close_price)\r\n        )\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error fetching recommendations:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getPerformanceMetrics() {\r\n    /**\r\n     * Get system performance and analysis metrics\r\n     * Returns: Statistical summary of system performance\r\n     */\r\n    try {\r\n      if (!this.client) await this.connect();\r\n\r\n      // Count total records\r\n      const totalDaysQuery = 'SELECT COUNT(*) as count FROM daily_metrics';\r\n      const totalRecommendationsQuery = 'SELECT COUNT(*) as count FROM ai_recommendations';\r\n      \r\n      // Sentiment distribution\r\n      const sentimentQuery = `\r\n        SELECT sentiment, COUNT(*) as count \r\n        FROM ai_recommendations \r\n        GROUP BY sentiment\r\n      `;\r\n      \r\n      // Average risk score\r\n      const avgRiskQuery = 'SELECT AVG(risk_score) as avg_risk FROM ai_recommendations';\r\n      \r\n      // Price range analysis\r\n      const priceRangeQuery = `\r\n        SELECT \r\n          MIN(close_price) as min_price,\r\n          MAX(close_price) as max_price,\r\n          AVG(close_price) as avg_price,\r\n          AVG(volume) as avg_volume\r\n        FROM daily_metrics\r\n      `;\r\n\r\n      const [totalDays, totalRecs, sentiments, avgRisk, priceRange] = await Promise.all([\r\n        this.client.query(totalDaysQuery),\r\n        this.client.query(totalRecommendationsQuery),\r\n        this.client.query(sentimentQuery),\r\n        this.client.query(avgRiskQuery),\r\n        this.client.query(priceRangeQuery)\r\n      ]);\r\n\r\n      // Format sentiment distribution\r\n      const sentimentDistribution = {};\r\n      sentiments.rows.forEach(row => {\r\n        sentimentDistribution[row.sentiment] = parseInt(row.count);\r\n      });\r\n\r\n      return {\r\n        totalDaysAnalyzed: parseInt(totalDays.rows[0].count),\r\n        totalRecommendations: parseInt(totalRecs.rows[0].count),\r\n        sentimentDistribution,\r\n        averageRiskScore: parseFloat(avgRisk.rows[0].avg_risk || 0).toFixed(2),\r\n        priceMetrics: {\r\n          minPrice: parseFloat(priceRange.rows[0].min_price || 0),\r\n          maxPrice: parseFloat(priceRange.rows[0].max_price || 0),\r\n          avgPrice: parseFloat(priceRange.rows[0].avg_price || 0),\r\n          avgVolume: parseInt(priceRange.rows[0].avg_volume || 0)\r\n        },\r\n        lastUpdated: new Date().toISOString()\r\n      };\r\n    } catch (error) {\r\n      console.error('Error fetching performance metrics:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  calculatePredictionAccuracy(predicted, actual) {\r\n    /**\r\n     * Calculate how accurate the AI price prediction was\r\n     * Returns: Accuracy percentage\r\n     */\r\n    if (!predicted || !actual) return 0;\r\n    \r\n    const difference = Math.abs(predicted - actual);\r\n    const accuracy = Math.max(0, 100 - (difference / actual * 100));\r\n    return parseFloat(accuracy.toFixed(2));\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nconst databaseService = new DatabaseService();\r\nexport default databaseService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}